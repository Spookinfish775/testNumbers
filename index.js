let chain = [1, 4, 2, 8, 3, 12, 9, 10, 11]

//  первая реализация
function firstSearch(arr) {
    let min = Math.min(...arr)  //  инициализация минимального значения из массива
    let max = Math.max(...arr)  //  инициализация максимального значения из массива

    let newArr = [] // инициализация массива для заполнения числами в диапозоне от минимального до максимального

    for (let i = min; i < max + 1; i++) {   //  цикл заполняет массив в диапозоне от минимального до максимального
        newArr.push(i)
    }

    return newArr.filter(el => !arr.includes(el))   //  возврат отфилтрованного массива с пропущенными числами
}


//  вторая реализация
function secondSearch(arr) {
    arr.sort((a, b) => a - b);  // сортировка входящего массива
    let missed = []             // инициализация массива для вывода пропущенных чисел

    for (let i = 0; i < arr.length; i++) {
        let current = arr[i]  // инициализация текущего элемента массива
        let next = arr[i + 1]  // инициализация последующего элемента массива для сравнения с предыдущим

        if (next - current !== 1) {  // проверка на пропуск числа 
            let difference = next - current - 1  // разница между числами (если больше одного значит присутствует пропуск)
            for (let j = 0; j < difference; j++) {  // поиск пропущенного числа
                missed.push(++current)
            }
        }
    }
    return missed
}

console.log(firstSearch(chain));
console.log(secondSearch(chain));

//  по поводу коментария к заданию.
//  немного доработанные функции.
//  которые работают сразу с несколькими
//  пропусками в массиве.
//  не зависит от того сколько их
//  и в каком месте.